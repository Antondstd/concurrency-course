# (Stackful) Coroutine

_Сопрограмма_ (_coroutine_) или просто _корутина_ – это процедура,
из вызова которой можно выйти (_остановить_ вызов, операция _suspend_), а затем вернуться в этот вызов
и продолжить исполнение с точки остановки (_возобновить_ вызов, операция _resume_).

Сопрограмма расширяет понятие _подпрограммы_ (_subroutine_), вызов которой нельзя остановить, а можно лишь завершить.

## `Coroutine`

Наша корутина будет выглядеть так:

```cpp
void StackfulCoroutineExample() {
  // Экземпляр класса Coroutine представляет _вызов_ корутины
  Coroutine coro([](auto self) {  // self имеет тип Coroutine::SuspendContext
    // Процедура (тело корутины) не имеет прямого доступа к объекту Coroutine.
    //
    // Чтобы остановить свое исполнение, процедура использует
    // объект SuspendContext с единственным методом Suspend, который получает
    // единственным аргументом.
    //
    // SuspendContext - trivially copyable
    
    // Роль: callee
    
    fmt::println("Step 2");
    
    // Вызов Suspend() на SuspendContext корутины останавливает ее исполнение 
    // и возвращает управление caller-у, завершая его вызов coro.Resume().
    self.Suspend();  // <-- Suspension point

    fmt::println("Step 4");
    
    // При завершении корутина возвращает управление
    // caller-у, в данном случае – завершает второй внешний
    // вызов coro.Resume()
  });
  
  // Исполнение корутины пока не началось

  fmt::println("Step 1");

  // Роль: caller
  
  // Стартуем корутину
  // Управление передается процедуре корутины coro,
  // та исполняется до первого вызова Suspend() на своем SuspendContext.
  coro.Resume();

  fmt::println("Step 3");
  
  // Возвращаем управление остановленной корутине,
  // в ней завершается вызов self.Suspend(), и она продолжает исполнение
  // (до следующей точки остановки или завершения процедуры).
  coro.Resume();

  // Вызов IsCompleted() возвращает true если корутина завершила 
  // свое исполнение, иначе false.
  assert(coro.IsCompleted());
}
```

На экране будет напечатано:
```
Step 1
Step 2
Step 3
Step 4
```

## Автомат

На корутину можно смотреть как на _автомат_ (_state machine_):
- его состояния – это состояния процедуры в _точках остановки_ (_suspension points_),
- переход в новое состояние начинается с операции _resume_ и завершается операцией _suspend_.

## Типы корутин

Реализация этого автомата определяет тип корутины:

- В (нашей) _stackful_ корутине автомат реализуется через манипуляции с контекстом исполнения. Состояние остановленной stackful корутины – стек вызовов и набор регистров.  

- В _stackless_ реализации корутина переписывается в явный автомат компилятором.

## C++

В С++ вы можете выбрать как [stackful](https://www.boost.org/doc/libs/1_75_0/libs/coroutine2/doc/html/index.html), так и [stackless](https://en.cppreference.com/w/cpp/language/coroutines) подход.

## Приложения
 
Корутина задает правила и механику передачи управления между caller и callee, но не задает при этом смысл этой передачи. 

На корутину нужно смотреть как на инструмент, который можно приложить к разным задачам и наделить
операции конкретным смыслом.

Приведем пару примеров:

### Итераторы

[Iteration Inside and Out](https://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/):

- Корутину возобновляет пользователь, который «крутит» итератор
- Корутина возвращает управление когда посещает в рекурсивном вызове очередной элемент древесного контейнера

### Файберы

Stackful корутины интересны нам в первую очередь как инструмент реализации кооперативной многозадачности в форме файберов.

- Корутину возобновляет поток пула, который в цикле выполняет запланированные в него задачи
- Корутина возвращает управление когда файбер останавливается на примитиве синхронизации (например, на мьютексе, которым владеет другой файбер)

См. задачу [fiber/yield](/tasks/fiber/yield).

## Задание

Реализуйте [`Coroutine`](coroutine.cpp) – stackful корутину

## Реализация

### `ExecutionContext`

В реализации вам потребуется [`ExecutionContext`](https://gitlab.com/Lipovsky/sure/-/blob/master/source/sure/context.hpp).

1) Прочтите [документацию](https://gitlab.com/Lipovsky/sure/-/blob/master/docs/ru/guide.md)
2) Посмотрите как `ExecutionContext` используется в [TinyFiber](https://gitlab.com/Lipovsky/tinyfiber)

### Исключения

Будем считать, что необработанное пользователем исключение в процедуре корутины – UB.

### API

Набор публичных методов `Coroutine` зафиксирован, менять его не следует.